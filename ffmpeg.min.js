// FFmpeg.wasm v0.12 - Simplified for Chrome Extension
// Uses fetch instead of dynamic script loading to comply with CSP

(function() {
  'use strict';

  const FFmpegModule = {
    _instance: null,
    _loaded: false,
    
    async loadCore(corePath) {
      if (this._loaded) return this._instance;
      
      try {
        // Fetch the FFmpeg core module
        const response = await fetch(corePath);
        const code = await response.text();
        
        // Create a function from the code and execute it
        const createModule = new Function('Module', code + '; return Module;');
        
        // Initialize FFmpeg Module
        const Module = {
          print: (text) => console.log('FFmpeg:', text),
          printErr: (text) => console.error('FFmpeg:', text),
          locateFile: (path, prefix) => {
            if (path.endsWith('.wasm')) {
              return 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/' + path;
            }
            return prefix + path;
          }
        };
        
        this._instance = await createModule(Module);
        this._loaded = true;
        
        return this._instance;
      } catch (error) {
        console.error('Failed to load FFmpeg core:', error);
        throw new Error('Failed to initialize FFmpeg: ' + error.message);
      }
    }
  };

  const FFmpeg = {
    createFFmpeg: function(config = {}) {
      return {
        _config: config,
        _loaded: false,
        _module: null,
        _fs: null,
        
        async load() {
          if (this._loaded) return;
          
          try {
            this._module = await FFmpegModule.loadCore(this._config.corePath);
            this._fs = this._module.FS;
            this._loaded = true;
            
            if (this._config.log) {
              console.log('FFmpeg loaded successfully');
            }
          } catch (error) {
            throw new Error('Failed to load FFmpeg: ' + error.message);
          }
        },
        
        FS(method, ...args) {
          if (!this._loaded || !this._fs) {
            throw new Error('FFmpeg not loaded. Call load() first.');
          }
          
          try {
            if (method === 'writeFile') {
              return this._fs.writeFile(args[0], args[1]);
            } else if (method === 'readFile') {
              return this._fs.readFile(args[0]);
            } else if (method === 'unlink') {
              try {
                return this._fs.unlink(args[0]);
              } catch (e) {
                // File might not exist, ignore
              }
            } else if (method === 'mkdir') {
              return this._fs.mkdir(args[0]);
            } else if (method === 'readdir') {
              return this._fs.readdir(args[0]);
            }
          } catch (error) {
            console.error('FS operation failed:', error);
            throw error;
          }
        },
        
        async run(...args) {
          if (!this._loaded || !this._module) {
            throw new Error('FFmpeg not loaded. Call load() first.');
          }
          
          return new Promise((resolve, reject) => {
            try {
              const progressCallback = this._config.progress;
              let lastProgress = 0;
              
              // Simulate progress for now
              const progressInterval = setInterval(() => {
                if (progressCallback && lastProgress < 0.9) {
                  lastProgress += 0.1;
                  progressCallback({ ratio: lastProgress });
                }
              }, 500);
              
              // Log command if enabled
              if (this._config.log) {
                console.log('FFmpeg command:', args.join(' '));
              }
              
              // Execute FFmpeg command
              this._module.callMain(args);
              
              clearInterval(progressInterval);
              
              // Final progress update
              if (progressCallback) {
                progressCallback({ ratio: 1 });
              }
              
              resolve();
            } catch (error) {
              console.error('FFmpeg execution failed:', error);
              reject(new Error('FFmpeg conversion failed: ' + error.message));
            }
          });
        }
      };
    },
    
    fetchFile: async function(file) {
      if (file instanceof File || file instanceof Blob) {
        return new Uint8Array(await file.arrayBuffer());
      } else if (typeof file === 'string') {
        // Handle URL
        const response = await fetch(file);
        return new Uint8Array(await response.arrayBuffer());
      }
      throw new Error('Invalid file type for fetchFile');
    }
  };

  // Expose globally
  window.FFmpeg = FFmpeg;
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = FFmpeg;
  }
})();
